/*
 * MegaMek - Copyright (C) 2005 Ben Mazur (bmazur@sev.org)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */
package megamek.client.ratgenerator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import megamek.common.Compute;
import megamek.common.MechSummary;
import megamek.common.MechSummaryCache;

/**
 * Manages random assignment table generated by RATGenerator.
 * 
 * @author Neoancient
 *
 */
public class UnitTable {
	private ArrayList<TableEntry> table = new ArrayList<TableEntry>();
	private FactionRecord faction;
	private String unitType;
	private int year;
	private int rating;
	private Collection<Integer> weightClasses;
	private Collection<MissionRole> roles;
	private int roleStrictness;
	private FactionRecord deployingFaction;
	private HashMap<String,UnitTable> salvageCache =
			new HashMap<String,UnitTable>();
	
	public UnitTable(FactionRecord faction, String unitType, int year,
			int rating, Collection<Integer> weightClasses,
			Collection<MissionRole> roles, int roleStrictness, FactionRecord deployingFaction) {
		this.faction = faction;
		this.unitType = unitType;
		this.year = year;
		this.rating = rating;
		this.weightClasses = weightClasses;
		this.roles = roles;
		this.roleStrictness = roleStrictness;
		this.deployingFaction = deployingFaction;
		generateTable();
	}
	
	public UnitTable(FactionRecord faction, String unitType, int year,
			int rating, Collection<Integer> weightClasses,
			Collection<MissionRole> roles, int roleStrictness) {
		this(faction, unitType, year, rating, weightClasses,
				roles, roleStrictness, faction);
	}
	
	private void generateTable() {
		table = new ArrayList<TableEntry>();
		Map<String,Double> generated = RATGenerator.getInstance().generateTable(faction,
				unitType, year, rating, weightClasses, roles, roleStrictness, deployingFaction);
		for (String key : generated.keySet()) {
			int weight = (int)(generated.get(key) + 0.5);
			if (weight > 0) {
				try {
					TableEntry entry = new TableEntry(weight, key);
					table.add(entry);
				} catch (IllegalArgumentException ex) {
					System.err.println(ex.getMessage());
				}
			}
		}
	}
	
	public int getNumEntries() {
		return table.size();
	}
	
	public int getEntryWeight(int index) {
		return table.get(index).weight;
	}
	
	public String getEntryText(int index) {
		if (table.get(index).isUnit()) {
			return table.get(index).getUnitEntry().getName();
		} else {
			if (faction.isClan()) {
				return "Isorla: " + table.get(index).getSalvageFaction().getName(year);
			} else {
				return "Salvage: " + table.get(index).getSalvageFaction().getName(year);
			}
		}
	}
	
	public int getBV(int index) {
		if (table.get(index).isUnit()) {
			return table.get(index).getUnitEntry().getBV();
		} else {
			return 0;
		}
	}
	
	public boolean hasUnits() {
		for (TableEntry entry : table) {
			if (entry.isUnit()) {
				return true;
			}
		}
		return false;
	}
	
	public ArrayList<MechSummary> generateUnits(int num) {
		ArrayList<MechSummary> retVal = new ArrayList<MechSummary>();
		ArrayList<TableEntry> weightedList = new ArrayList<TableEntry>();
		for (TableEntry entry : table) {
			for (int i = 0; i < entry.weight; i++) {
				weightedList.add(entry);
			}
		}
		while (retVal.size() < num && weightedList.size() > 0) {
			TableEntry entry = weightedList.get(Compute.randomInt(weightedList.size()));
			if (entry.isUnit()) {
				retVal.add(entry.getUnitEntry());
			} else {
				UnitTable salvage = salvageCache.get(entry.getSalvageFaction().getKey());
				if (salvage == null) {
					salvage = new UnitTable(entry.getSalvageFaction(),
							unitType, year, rating, weightClasses,
							roles, roleStrictness, faction);
					if (salvage.hasUnits()) {
						salvageCache.put(entry.getSalvageFaction().getKey(), salvage);
					} else {
						table.remove(entry);
						while (weightedList.remove(entry));
						continue;
					}
				}
				retVal.addAll(salvage.generateUnits(1));
			}
		}
		return retVal;
	}
	
	public class TableEntry {
		int weight;
		Object entry;
		
		public TableEntry(int weight, String entryName) {
			this.weight = weight;
			if (entryName.startsWith("@")) {
				entry = RATGenerator.getInstance().getFaction(entryName.replace("@", ""));
			} else {
				entry = MechSummaryCache.getInstance().getMech(entryName);
			}
			if (entry == null) {
				throw new IllegalArgumentException("RATGenerator could not parse entry " + entryName);
			}
		}
		
		public MechSummary getUnitEntry() {
			return (MechSummary)entry;
		}
		
		public FactionRecord getSalvageFaction() {
			return (FactionRecord)entry;
		}
		
		public boolean isUnit() {
			return entry instanceof MechSummary;
		}
	}
}
