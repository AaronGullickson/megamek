/*
 * MegaMek - Copyright (C) 2005 Ben Mazur (bmazur@sev.org)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */
package megamek.client.ratgenerator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import megamek.common.Compute;
import megamek.common.MechSummary;

/**
 * Manages random assignment table generated by RATGenerator.
 * 
 * @author Neoancient
 *
 */
public class UnitTable {
	private List<TableEntry> table = new ArrayList<TableEntry>();
	private FactionRecord faction;
	private int unitType;
	private int year;
	private String rating;
	private Collection<Integer> weightClasses;
	private int networkMask;
	private Collection<String> subtypes;
	private Collection<MissionRole> roles;
	private int roleStrictness;
	private FactionRecord deployingFaction;
	private HashMap<String,UnitTable> salvageCache =
			new HashMap<String,UnitTable>();
	
	public UnitTable(FactionRecord faction, int unitType, int year,
			String rating, Collection<Integer> weightClasses, int networkMask, Collection<String> subtypes,
			Collection<MissionRole> roles, int roleStrictness, FactionRecord deployingFaction) {
		this.faction = faction;
		this.unitType = unitType;
		this.year = year;
		this.rating = rating;
		this.weightClasses = weightClasses;
		this.networkMask = networkMask;
		this.subtypes = subtypes;
		this.roles = roles;
		this.roleStrictness = roleStrictness;
		this.deployingFaction = deployingFaction;
		generateTable();
	}
	
	public UnitTable(FactionRecord faction, int unitType, int year,
			String rating, Collection<Integer> weightClasses, int networkMask,
			Collection<String> subtypes,
			Collection<MissionRole> roles, int roleStrictness) {
		this(faction, unitType, year, rating, weightClasses, networkMask, subtypes,
				roles, roleStrictness, faction);
	}
	
	private void generateTable() {
		if (!faction.isActiveInYear(year)) {
			return;
		}
		table = RATGenerator.getInstance().generateTable(faction,
				unitType, year, rating, weightClasses, networkMask, subtypes,
				roles, roleStrictness, deployingFaction);
		Collections.sort(table);
	}
	
	public int getNumEntries() {
		return table.size();
	}
	
	public int getEntryWeight(int index) {
		return table.get(index).weight;
	}
	
	public String getEntryText(int index) {
		if (table.get(index).isUnit()) {
			return table.get(index).getUnitEntry().getName();
		} else {
			if (faction.isClan()) {
				return "Isorla: " + table.get(index).getSalvageFaction().getName(year - 5);
			} else {
				return "Salvage: " + table.get(index).getSalvageFaction().getName(year - 5);
			}
		}
	}
	
	public MechSummary getMechSummary(int index) {
		if (table.get(index).isUnit()) {
			return table.get(index).getUnitEntry();
		}
		return null;
	}
	
	public int getBV(int index) {
		if (table.get(index).isUnit()) {
			return table.get(index).getUnitEntry().getBV();
		} else {
			return 0;
		}
	}
	
	public boolean hasUnits() {
		for (TableEntry entry : table) {
			if (entry.isUnit()) {
				return true;
			}
		}
		return false;
	}
	
	public ArrayList<MechSummary> generateUnits(int num) {
		ArrayList<MechSummary> retVal = new ArrayList<MechSummary>();
		ArrayList<TableEntry> weightedList = new ArrayList<TableEntry>();
		for (TableEntry entry : table) {
			for (int i = 0; i < entry.weight; i++) {
				weightedList.add(entry);
			}
		}
		while (retVal.size() < num && weightedList.size() > 0) {
			TableEntry entry = weightedList.get(Compute.randomInt(weightedList.size()));
			if (entry.isUnit()) {
				retVal.add(entry.getUnitEntry());
			} else {
				UnitTable salvage = salvageCache.get(entry.getSalvageFaction().getKey());
				if (salvage == null) {
					salvage = new UnitTable(entry.getSalvageFaction(),
							unitType, year - 5, rating, weightClasses, networkMask, subtypes,
							roles, roleStrictness, faction);
					if (salvage.hasUnits()) {
						salvageCache.put(entry.getSalvageFaction().getKey(), salvage);
					} else {
						table.remove(entry);
						while (weightedList.remove(entry));
						continue;
					}
				}
				retVal.addAll(salvage.generateUnits(1));
			}
		}
		return retVal;
	}
	
	public static class TableEntry implements Comparable<TableEntry> {
		int weight;
		Object entry;
		
		public TableEntry(int weight, Object entry) {
			this.weight = weight;
			this.entry = entry;
		}
		
		public MechSummary getUnitEntry() {
			return (MechSummary)entry;
		}
		
		public FactionRecord getSalvageFaction() {
			return (FactionRecord)entry;
		}
		
		public boolean isUnit() {
			return entry instanceof MechSummary;
		}

		@Override
		public int compareTo(TableEntry other) {
			if (entry instanceof MechSummary && other.entry instanceof FactionRecord) {
				return 1;
			}
			if (entry instanceof FactionRecord && other.entry instanceof MechSummary) {
				return -1;
			}
			return toString().compareTo(other.toString());
		}
			
		@Override
		public String toString() {
			if (entry instanceof MechSummary) {
				return ((MechSummary)entry).getName();
			}
			return entry.toString();
		}
	}
}
