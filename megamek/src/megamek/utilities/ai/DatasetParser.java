/*
 * Copyright (c) 2025 - The MegaMek Team. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 */
package megamek.utilities.ai;

import megamek.common.*;
import megamek.common.util.StringUtil;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Parses a dataset from one or more files and turns it into a training dataset.
 * The dataset currently expected is the game_actions_log.tsv file generated by the megamek client hosting the game if the
 * option is enabled
 * @author Luana Coppio
 */
public class DatasetParser {

    // attackAction is not being considered right now
    private final List<ActionAndState> actionAndStates = new ArrayList<>();
    private final Map<Integer, Entity> entities = new HashMap<>();
    private int idOffset = 0;
    private int highestEntityId = 0;

    /**
     * Parses a dataset from a file. Can be chained with other parse calls to create a large single training dataset.
     * @param file The file to parse
     * @return The parser instance
     */
    public DatasetParser parse(File file) {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.startsWith("PLAYER_ID\tENTITY_ID\tCHASSIS\tMODEL\tFACING\tFROM_X\tFROM_Y\tTO_X\tTO_Y\tHEXES_MOVED\tDISTANCE\tMP_USED\tMAX_MP\tMP_P\tHEAT_P\tARMOR_P\tINTERNAL_P\tJUMPING\tPRONE\tLEGAL\tSTEPS")) {
                    // Parse action line
                    String actionLine = reader.readLine();
                    if (actionLine == null) break;
                    UnitAction action = parseActionLine(actionLine);

                    // Parse state block
                    line = reader.readLine(); // State header
                    if (line == null || !line.startsWith("ROUND\tPHASE\tPLAYER_ID\tENTITY_ID\tCHASSIS\tMODEL\tTYPE\tROLE\tX\tY\tFACING\tMP\tHEAT\tPRONE\tAIRBORNE\tOFF_BOARD\tCRIPPLED\tDESTROYED\tARMOR_P\tINTERNAL_P\tDONE")) {
                        // || !line.startsWith("ROUND\tPHASE\tTEAM_ID\tPLAYER_ID\tENTITY_ID\tCHASSIS\tMODEL\tTYPE\tROLE\tX\tY\tFACING\tMP\tHEAT\tPRONE\tAIRBORNE\tOFF_BOARD\tCRIPPLED\tDESTROYED\tARMOR_P\tINTERNAL_P\tDONE")) {

                        if (line == null // || !line.startsWith("ROUND\tPHASE\tPLAYER_ID\tENTITY_ID\tCHASSIS\tMODEL\tTYPE\tROLE\tX\tY\tFACING\tMP\tHEAT\tPRONE\tAIRBORNE\tOFF_BOARD\tCRIPPLED\tDESTROYED\tARMOR_P\tINTERNAL_P\tDONE")) {
                            || !line.startsWith("ROUND\tPHASE\tTEAM_ID\tPLAYER_ID\tENTITY_ID\tCHASSIS\tMODEL\tTYPE\tROLE\tX\tY\tFACING\tMP\tHEAT\tPRONE\tAIRBORNE\tOFF_BOARD\tCRIPPLED\tDESTROYED\tARMOR_P\tINTERNAL_P\tDONE")) {
                            throw new RuntimeException("Invalid state header after action: " + line);
                        }

                    }

                    List<UnitState> states = new ArrayList<>();
                    Integer currentRound = null;
                    while ((line = reader.readLine()) != null && (!line.startsWith("PLAYER_ID\tENTITY_ID"))) {
                        if (line.trim().isEmpty()) continue;
                        if (line.startsWith("ROUND")) break;
                        UnitState state = parseStateLine(line);
                        if (currentRound == null) {
                            currentRound = state.round();
                        } else if (currentRound != state.round()) {
                            throw new RuntimeException("State block has inconsistent rounds");
                        }
                        states.add(state);
                    }

                    if (currentRound == null) {
                        throw new RuntimeException("State block has no valid states");
                    }
                    actionAndStates.add(new ActionAndState(currentRound, action, states));

                    // If line is an action header, the outer loop will handle it
                    // we are not currently parsing and using attack actions on the dataset right now.
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Error reading file", e);
        }

        idOffset = highestEntityId + 1;
        return this;
    }

    /**
     * Get the training dataset from the parsed files.
     * This will throw an exception if no actions and states were found or no parsing was done.
     * @return The training dataset
     */
    public TrainingDataset getTrainingDataset() {
        if (actionAndStates.isEmpty()) {
            throw new RuntimeException("No actions and states found in dataset, you need to parse a file first");
        }
        return new TrainingDataset(actionAndStates);
    }

    private UnitAction parseActionLine(String actionLine) {
        String[] parts = actionLine.split("\t");
        int entityId = Integer.parseInt(parts[1]) + idOffset;
        int facing = Integer.parseInt(parts[4]);
        int fromX = Integer.parseInt(parts[5]);
        int fromY = Integer.parseInt(parts[6]);
        int toX = Integer.parseInt(parts[7]);
        int toY = Integer.parseInt(parts[8]);
        int hexesMoved = Integer.parseInt(parts[9]);
        int distance = Integer.parseInt(parts[10]);
        int mpUsed = Integer.parseInt(parts[11]);
        int maxMp = Integer.parseInt(parts[12]);
        double mpP = Double.parseDouble(parts[13]);
        double heatP = Double.parseDouble(parts[14]);
        double armorP = Double.parseDouble(parts[15]);
        double internalP = Double.parseDouble(parts[16]);
        boolean jumping = parts[17].equals("1");
        boolean prone = parts[18].equals("1");
        boolean legal = parts[19].equals("1");
        // Need to check if the unit in the previous turn had moved or not
        if (highestEntityId < entityId) {
            highestEntityId = entityId;
        }
        return new UnitAction(entityId, facing, fromX, fromY, toX, toY, hexesMoved, distance, mpUsed, maxMp, mpP, heatP, armorP,
            internalP, jumping, prone, legal);
    }

    private UnitState parseStateLine(String stateLine) {
        int index = 0;
        String[] parts = stateLine.split("\t");
        int round = Integer.parseInt(parts[index++]);
        index++;
        int teamId = -1;
        if (StringUtil.isInteger(parts[4])) {
            teamId = Integer.parseInt(parts[index++]);
        }
        int playerId = Integer.parseInt(parts[index++]);
        int entityId = Integer.parseInt(parts[index++]) + idOffset;
        String chassis = parts[index++];
        String model = parts[index++];
        String type = parts[index++];
        UnitRole role = UnitRole.valueOf(parts[index++]);
        int x = Integer.parseInt(parts[index++]);
        int y = Integer.parseInt(parts[index++]);
        int facing = Integer.parseInt(parts[index++]);
        double mp = Double.parseDouble(parts[index++]);
        double heat = Double.parseDouble(parts[index++]);
        boolean prone = parts[index++].equals("1");
        boolean airborne = parts[index++].equals("1");
        boolean offBoard = parts[index++].equals("1");
        boolean crippled = parts[index++].equals("1");
        boolean destroyed = parts[index++].equals("1");
        double armorP = Double.parseDouble(parts[index++]);
        double internalP = Double.parseDouble(parts[index++]);
        boolean done = parts[index].equals("1");
        int maxRange = 0;
        int turnsWithoutMovement = 0;
        int totalDamage = 0;
        Entity entity = null;
        if (!type.equals("MekWarrior") && !type.equals("EjectedCrew")) {
            entity = entities.computeIfAbsent(entityId, i -> MekSummary.loadEntity(chassis + " " + model));
        }

        if (entity != null) {
            maxRange = entity.getMaxWeaponRange();
            totalDamage = Compute.computeTotalDamage(entity.getWeaponList());
            entity.setInitialBV(entity.calculateBattleValue(true, true));
            entity.setId(entityId);
        }
        if (highestEntityId < entityId) {
            highestEntityId = entityId;
        }
        return new UnitState(entityId, teamId, round, playerId, chassis, model, type, role, x, y, facing, mp, heat, prone, airborne, offBoard,
            crippled, destroyed, armorP, internalP, done,maxRange, totalDamage, turnsWithoutMovement, entity);
    }
}
